{
    "technology": "spring-boot",
    "displayName": "Spring Boot",
    "category": "FRAMEWORK",
    "difficulty": "INTERMEDIATE",
    "relations": [
        {
            "to": "java",
            "type": "DEPENDS_ON"
        },
        {
            "to": "spring-framework",
            "type": "EXTENDS"
        },
        {
            "to": "kotlin",
            "type": "USED_WITH"
        },
        {
            "to": "spring-data",
            "type": "CONTAINS"
        },
        {
            "to": "db-mysql",
            "type": "USED_WITH"
        }
    ],
    "documents": [
        {
            "type": "ROADMAP",
            "source": "roadmap.sh/spring-boot + spring.io/guides",
            "content": "# Spring Boot 학습 로드맵\n\n## 필수 선행 지식\n- Java 기본 문법 (Java 8+ 권장)\n- 객체지향 프로그래밍\n- Maven 또는 Gradle 기초\n- HTTP/REST API 개념\n- SQL 기본 (SELECT, INSERT, UPDATE, DELETE)\n\n## 전체 학습 시간: 약 80시간\n\n---\n\n## 1단계: Spring Boot 기초 (20시간)\n\n### 목표\nSpring Boot의 핵심 개념과 자동 설정을 이해합니다.\n\n### 학습 내용\n\n**1.1 Spring Boot 소개 (3시간)**\n- Spring vs Spring Boot 차이점\n- 자동 설정 (Auto-configuration)\n- Spring Initializr로 프로젝트 생성\n- application.properties vs application.yml\n\n**1.2 의존성 주입 (DI) (5시간)**\n- @Component, @Service, @Repository\n- @Autowired, 생성자 주입\n- 싱글톤 vs 프로토타입 스코프\n- @Configuration과 @Bean\n\n**1.3 Spring Boot Starter (3시간)**\n- spring-boot-starter-web\n- spring-boot-starter-data-jpa\n- spring-boot-starter-test\n- 커스텀 starter 만들기\n\n**1.4 프로파일과 설정 (4시간)**\n- application-{profile}.yml\n- @Value, @ConfigurationProperties\n- 환경 변수 주입\n- 프로파일별 빈 등록\n\n**1.5 Spring Boot Actuator (5시간)**\n- /actuator/health, /metrics\n- 커스텀 헬스 체크\n- 프로덕션 모니터링\n\n### 실습 프로젝트\n간단한 REST API 서버\n- CRUD 엔드포인트\n- 의존성 주입으로 계층 분리\n- 프로파일별 설정 (dev, prod)\n\n---\n\n## 2단계: Spring Web MVC (15시간)\n\n### 목표\nREST API를 구현하고 요청/응답을 처리합니다.\n\n### 학습 내용\n\n**2.1 Controller (4시간)**\n- @RestController vs @Controller\n- @GetMapping, @PostMapping 등\n- @PathVariable, @RequestParam\n- @RequestBody, @ResponseBody\n\n**2.2 요청 검증 (3시간)**\n- @Valid, @Validated\n- Jakarta Bean Validation\n- 커스텀 Validator\n- BindingResult\n\n**2.3 예외 처리 (4시간)**\n- @ControllerAdvice\n- @ExceptionHandler\n- ResponseEntity\n- 커스텀 예외 클래스\n\n**2.4 응답 형식 (2시간)**\n- JSON 직렬화/역직렬화\n- @JsonProperty, @JsonIgnore\n- 날짜 포맷 설정\n\n**2.5 필터와 인터셉터 (2시간)**\n- Filter vs Interceptor\n- 요청 로깅\n- CORS 설정\n\n### 실습 프로젝트\n블로그 API\n- 게시글 CRUD\n- 입력 검증 및 예외 처리\n- 공통 응답 포맷\n\n---\n\n## 3단계: Spring Data JPA (20시간)\n\n### 목표\nJPA로 데이터베이스를 다루고 효율적인 쿼리를 작성합니다.\n\n### 학습 내용\n\n**3.1 JPA 기초 (5시간)**\n- @Entity, @Table\n- @Id, @GeneratedValue\n- @Column, @Transient\n- 영속성 컨텍스트\n\n**3.2 Repository (4시간)**\n- JpaRepository<T, ID>\n- 쿼리 메서드 (findByName 등)\n- @Query (JPQL)\n- Native Query\n\n**3.3 연관관계 매핑 (5시간)**\n- @OneToMany, @ManyToOne\n- @ManyToMany\n- 양방향 vs 단방향\n- Fetch 전략 (Lazy vs Eager)\n- N+1 문제 해결\n\n**3.4 트랜잭션 (3시간)**\n- @Transactional\n- 트랜잭션 전파 (Propagation)\n- 격리 수준 (Isolation)\n- 롤백 규칙\n\n**3.5 QueryDSL (3시간)**\n- 타입 안전한 쿼리\n- 동적 쿼리 작성\n- Specification 패턴\n\n### 실습 프로젝트\nE-commerce API\n- 상품, 주문, 회원 엔티티\n- 연관관계 매핑\n- 페이징 및 정렬\n\n---\n\n## 4단계: Spring Security (15시간)\n\n### 목표\n인증과 인가를 구현하여 API를 보호합니다.\n\n### 학습 내용\n\n**4.1 Security 기초 (4시간)**\n- SecurityFilterChain\n- UserDetailsService\n- PasswordEncoder (BCrypt)\n- 기본 인증 vs 폼 로그인\n\n**4.2 JWT 인증 (5시간)**\n- JWT 토큰 생성/검증\n- JwtAuthenticationFilter\n- 리프레시 토큰\n- @PreAuthorize\n\n**4.3 역할 기반 인가 (3시간)**\n- ROLE_USER, ROLE_ADMIN\n- @Secured, @RolesAllowed\n- 메서드 레벨 보안\n\n**4.4 OAuth 2.0 (3시간)**\n- Google, GitHub 로그인\n- OAuth2LoginAuthenticationFilter\n- 커스텀 OAuth2UserService\n\n### 실습 프로젝트\n회원 관리 API\n- 회원가입, 로그인\n- JWT 발급 및 검증\n- 역할별 권한 제어\n\n---\n\n## 5단계: 테스트 및 배포 (10시간)\n\n### 목표\n안정적인 애플리케이션을 테스트하고 배포합니다.\n\n### 학습 내용\n\n**5.1 단위 테스트 (3시간)**\n- @SpringBootTest\n- @WebMvcTest\n- @DataJpaTest\n- Mockito, MockMvc\n\n**5.2 통합 테스트 (3시간)**\n- TestContainers\n- 실제 DB 테스트\n- REST Assured\n\n**5.3 프로덕션 준비 (2시간)**\n- 로깅 (Logback)\n- 환경 설정 분리\n- 배포용 JAR 빌드\n\n**5.4 배포 (2시간)**\n- Docker 이미지 생성\n- AWS Elastic Beanstalk\n- 헬스 체크 엔드포인트\n\n### 실습 프로젝트\n미니 쇼핑몰 API 완성\n- 모든 기능 통합 테스트\n- Docker로 패키징\n- 클라우드 배포\n\n---\n\n## 학습 리소스\n\n### 공식 문서\n- Spring Boot Reference: https://spring.io/projects/spring-boot\n- Spring Guides: https://spring.io/guides\n\n### 추천 도서\n- 스프링 부트 핵심 가이드 (한국어)\n- Spring Boot in Action\n\n### 온라인 강의 (한국어)\n- 인프런: \"스프링 부트와 JPA 실무 완전 정복\"\n- 패스트캠퍼스: \"Spring Boot 백엔드 개발자 되기\"\n\n---\n\n## 다음 단계\n\n### 마이크로서비스\n- Spring Cloud (Config, Gateway)\n- Kafka, RabbitMQ\n- 분산 트레이싱 (Zipkin)\n\n### 고급 주제\n- Spring WebFlux (Reactive)\n- R2DBC (Reactive DB)\n- Kubernetes 배포"
        },
        {
            "type": "BEST_PRACTICE",
            "source": "spring.io/guides + 우아한형제들 기술 블로그",
            "content": "# Spring Boot 베스트 프랙티스\n\n## 프로젝트 구조\n\n### 레이어드 아키텍처\n```\ncom.example.project\n├── controller     # REST API 엔드포인트\n├── service        # 비즈니스 로직\n├── repository     # 데이터 접근\n├── domain         # 엔티티, VO\n└── dto            # 요청/응답 객체\n```\n\n### 패키지 분리 원칙\n- Controller: 요청 검증, 응답 포맷\n- Service: 비즈니스 로직, 트랜잭션\n- Repository: DB 쿼리\n- Domain: 엔티티는 비즈니스 로직 포함 가능 (DDD)\n\n---\n\n## 의존성 주입\n\n### 생성자 주입 (권장)\n```java\n@Service\npublic class UserService {\n    private final UserRepository userRepository;\n    \n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}\n```\n\n### 필드 주입 (지양)\n```java\n@Service\npublic class UserService {\n    @Autowired  // 테스트하기 어려움\n    private UserRepository userRepository;\n}\n```\n\n---\n\n## DTO vs Entity 분리\n\n### 올바른 패턴\n```java\n// Controller\n@PostMapping(\"/users\")\npublic ResponseEntity<UserResponse> createUser(@RequestBody UserRequest request) {\n    User user = userService.create(request);\n    return ResponseEntity.ok(UserResponse.from(user));\n}\n\n// Service\npublic User create(UserRequest request) {\n    User user = request.toEntity();\n    return userRepository.save(user);\n}\n```\n\n### 안티패턴\n```java\n// Entity를 직접 반환/받음 (지양)\n@PostMapping(\"/users\")\npublic User createUser(@RequestBody User user) {  // ❌\n    return userRepository.save(user);\n}\n```\n\n---\n\n## 예외 처리\n\n### GlobalExceptionHandler\n```java\n@RestControllerAdvice\npublic class GlobalExceptionHandler {\n    \n    @ExceptionHandler(IllegalArgumentException.class)\n    public ResponseEntity<ErrorResponse> handleIllegalArgument(IllegalArgumentException e) {\n        return ResponseEntity.badRequest()\n            .body(new ErrorResponse(\"INVALID_INPUT\", e.getMessage()));\n    }\n    \n    @ExceptionHandler(EntityNotFoundException.class)\n    public ResponseEntity<ErrorResponse> handleNotFound(EntityNotFoundException e) {\n        return ResponseEntity.status(HttpStatus.NOT_FOUND)\n            .body(new ErrorResponse(\"NOT_FOUND\", e.getMessage()));\n    }\n}\n```\n\n### 커스텀 예외\n```java\npublic class UserNotFoundException extends RuntimeException {\n    public UserNotFoundException(Long userId) {\n        super(\"User not found: \" + userId);\n    }\n}\n```\n\n---\n\n## JPA 사용\n\n### N+1 문제 해결\n```java\n// Bad\n@OneToMany(fetch = FetchType.EAGER)  // 모든 연관 엔티티 로드\n\n// Good\n@OneToMany(fetch = FetchType.LAZY)\nprivate List<Order> orders;\n\n// 쿼리에서 fetch join\n@Query(\"SELECT u FROM User u JOIN FETCH u.orders WHERE u.id = :id\")\nUser findByIdWithOrders(@Param(\"id\") Long id);\n```\n\n### 트랜잭션 범위\n```java\n// Service 레이어에서만 @Transactional\n@Service\npublic class UserService {\n    \n    @Transactional  // 서비스 메서드\n    public void updateUser(Long id, String name) {\n        User user = userRepository.findById(id)\n            .orElseThrow(() -> new UserNotFoundException(id));\n        user.updateName(name);\n        // 트랜잭션 커밋 시 자동 업데이트 (Dirty Checking)\n    }\n}\n```\n\n---\n\n## 설정 관리\n\n### application.yml 분리\n```yaml\n# application.yml (공통)\nspring:\n  application:\n    name: my-app\n\n---\n# application-dev.yml (개발)\nspring:\n  datasource:\n    url: jdbc:h2:mem:testdb\n\n---\n# application-prod.yml (프로덕션)\nspring:\n  datasource:\n    url: jdbc:mysql://prod-db:3306/myapp\n```\n\n### 환경 변수 주입\n```yaml\nspring:\n  datasource:\n    url: ${DATABASE_URL}  # 환경 변수\n    username: ${DB_USERNAME}\n    password: ${DB_PASSWORD}\n```\n\n---\n\n## 테스트\n\n### 계층별 테스트\n```java\n// Controller 테스트\n@WebMvcTest(UserController.class)\nclass UserControllerTest {\n    @Autowired MockMvc mockMvc;\n    @MockBean UserService userService;\n    \n    @Test\n    void getUser() throws Exception {\n        mockMvc.perform(get(\"/users/1\"))\n            .andExpect(status().isOk());\n    }\n}\n\n// Service 테스트\n@SpringBootTest\nclass UserServiceTest {\n    @Autowired UserService userService;\n    \n    @Test\n    void createUser() {\n        // given, when, then\n    }\n}\n\n// Repository 테스트\n@DataJpaTest\nclass UserRepositoryTest {\n    @Autowired UserRepository userRepository;\n    \n    @Test\n    void findByEmail() {\n        // ...\n    }\n}\n```\n\n---\n\n## 보안\n\n### 비밀번호 암호화\n```java\n@Bean\npublic PasswordEncoder passwordEncoder() {\n    return new BCryptPasswordEncoder();\n}\n```\n\n### CORS 설정\n```java\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n    @Override\n    public void addCorsMappings(CorsRegistry registry) {\n        registry.addMapping(\"/api/**\")\n            .allowedOrigins(\"http://localhost:3000\")\n            .allowedMethods(\"GET\", \"POST\", \"PUT\", \"DELETE\");\n    }\n}\n```\n\n---\n\n## 로깅\n\n### SLF4J 사용\n```java\n@Service\npublic class UserService {\n    private static final Logger logger = LoggerFactory.getLogger(UserService.class);\n    \n    public User create(UserRequest request) {\n        logger.info(\"Creating user: {}\", request.getEmail());\n        // ...\n    }\n}\n```\n\n### 로그 레벨 설정\n```yaml\nlogging:\n  level:\n    root: INFO\n    com.example: DEBUG\n    org.hibernate.SQL: DEBUG\n```"
        },
        {
            "type": "COMMUNITY_INSIGHT",
            "source": "우아한형제들, 카카오, 쿠팡 기술 블로그",
            "content": "# 실무에서 Spring Boot 배우기\n\n## 한국 기업의 Spring Boot 사용 사례\n\n### 우아한형제들 (배달의민족)\n- **아키텍처**: MSA (마이크로서비스)\n- **기술 스택**: Spring Boot 2.x + Kotlin + JPA\n- **특징**: 주문/배달 도메인 분리, 이벤트 기반 아키텍처\n\n### 카카오\n- **아키텍처**: Spring Cloud 기반 분산 시스템\n- **기술 스택**: Spring Boot + Kafka + Redis\n- **특징**: 대규모 트래픽 처리 (초당 수십만 요청)\n\n### 쿠팡\n- **아키텍처**: Spring Boot + WebFlux (Reactive)\n- **기술 스택**: R2DBC, Kotlin Coroutines\n- **특징**: 비동기 논블로킹으로 높은 동시성\n\n### 토스\n- **아키텍처**: Spring Boot + Kotlin 전사 표준\n- **기술 스택**: Domain-Driven Design 적용\n- **특징**: 도메인 중심 설계, 테스트 커버리지 80% 이상\n\n---\n\n## 초보자가 자주 하는 실수\n\n### 1. Entity를 그대로 반환\n```java\n// Bad\n@GetMapping(\"/users/{id}\")\npublic User getUser(@PathVariable Long id) {  // Entity 직접 노출\n    return userRepository.findById(id);\n}\n\n// Good\n@GetMapping(\"/users/{id}\")\npublic UserResponse getUser(@PathVariable Long id) {  // DTO 사용\n    User user = userService.findById(id);\n    return UserResponse.from(user);\n}\n```\n\n### 2. @Transactional 남용\n```java\n// Bad\n@Transactional  // 조회에는 불필요\npublic User findById(Long id) {\n    return userRepository.findById(id);\n}\n\n// Good\n@Transactional(readOnly = true)  // 읽기 전용 트랜잭션\npublic User findById(Long id) {\n    return userRepository.findById(id);\n}\n```\n\n### 3. 양방향 연관관계의 함정\n```java\n// 순환 참조 발생 가능\n@Entity\npublic class User {\n    @OneToMany(mappedBy = \"user\")\n    private List<Order> orders;  // JSON 직렬화 시 무한 루프\n}\n\n// 해결: DTO 사용 또는 @JsonIgnore\n```\n\n### 4. N+1 쿼리 문제 간과\n```java\n// 100명 유저 조회 시 101번 쿼리 실행\nList<User> users = userRepository.findAll();\nfor (User user : users) {\n    user.getOrders().size();  // 각 유저마다 쿼리 실행\n}\n\n// 해결: fetch join 사용\n@Query(\"SELECT u FROM User u JOIN FETCH u.orders\")\nList<User> findAllWithOrders();\n```\n\n---\n\n## 추천 학습 로드맵 (실무 중심)\n\n### 1단계: 기본 CRUD API (1주)\n- Spring Boot 프로젝트 생성\n- H2 DB로 간단한 TODO API\n- Postman으로 테스트\n\n### 2단계: 실전 프로젝트 (2-3주)\n- MySQL + JPA 연동\n- 회원가입/로그인 API\n- JWT 인증\n- 예외 처리\n\n### 3단계: 테스트 작성 (1주)\n- 레이어별 단위 테스트\n- 통합 테스트\n- Test Coverage 70% 이상\n\n### 4단계: 배포 (3-4일)\n- Docker 이미지 생성\n- AWS EC2 또는 Elastic Beanstalk\n- CI/CD 파이프라인 (GitHub Actions)\n\n---\n\n## 실무 팁\n\n### 1. 로컬 개발 환경\n- Docker Compose로 MySQL, Redis 실행\n- application-local.yml 별도 관리\n- H2 Console 활용 (개발 중 DB 확인)\n\n### 2. 코드 리뷰 체크리스트\n- [ ] DTO와 Entity 분리\n- [ ] Service에만 @Transactional\n- [ ] 예외 처리 (GlobalExceptionHandler)\n- [ ] 입력 검증 (@Valid)\n- [ ] 테스트 코드 작성\n\n### 3. 성능 최적화\n- **쿼리 로그 확인**: `spring.jpa.show-sql=true`\n- **N+1 해결**: fetch join 또는 @EntityGraph\n- **캐싱**: Redis 또는 @Cacheable\n- **Connection Pool**: HikariCP 튜닝\n\n### 4. 모니터링\n- Spring Boot Actuator\n- Prometheus + Grafana\n- 로그: ELK Stack (Elasticsearch, Logstash, Kibana)\n\n---\n\n## 추천 리소스 (한국어)\n\n### 온라인 강의\n- **인프런**: \"스프링 부트와 JPA 활용\" (김영한)\n- **인프런**: \"스프링 핵심 원리 - 기본편\"\n- **유데미**: \"Spring Boot 백엔드 개발자 되기\"\n\n### 책\n- 스프링 부트 핵심 가이드\n- 자바 ORM 표준 JPA 프로그래밍\n- 토비의 스프링 3.1 (고급)\n\n### 커뮤니티\n- 인프런 질문 게시판\n- 스프링 한국 사용자 모임\n- Slack: Spring Korea\n\n### 기술 블로그\n- 우아한형제들 기술 블로그\n- 카카오 Tech 블로그\n- 토스 Tech 블로그\n- NHN Cloud Meetup"
        }
    ]
}